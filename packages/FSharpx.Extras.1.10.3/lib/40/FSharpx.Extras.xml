<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Extras</name></assembly>
<members>
<member name="T:FSharpx.Cont`2">
<summary>
 The continuation monad.
 The algorithm is from Wes Dyer http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
 Current implementation from Matt&apos;s gist at https://gist.github.com/628956
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Coroutine">
<summary>
 The coroutine type from http://fssnip.net/7M
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncEx.Protect``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Encapsulates any possible exceptions during bind in a Choice
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpAsyncEx.IgnoreResult``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Ignores (discards) the result of the async computation
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpChoice.Value``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpChoice.Cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``3(System.Func{``0,``1,``2})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``2(System.Func{``0,``1})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``1(System.Func{``0})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``3(System.Action{``0,``1,``2})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``2(System.Action{``0,``1})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``1(System.Action{``0})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction(System.Action)">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="T:FSharpx.FSharpFunc">
 <summary>
 Conversion functions from Action/Func to FSharpFunc
 We need these because FuncConvert often makes C# type inference fail.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.Where``1(Microsoft.FSharp.Core.FSharpOption{``0},System.Predicate{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.ToFSharpList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts the option to a list of length 0 or 1
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts the option to an array of length 0 or 1
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.SelectMany``3(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Func{``0,``1,``2})">
<summary>
 Invokes a function on an optional value that itself yields an option,
 and then applies a mapping function
</summary>
</member>
<member name="M:FSharpx.FSharpOption.SelectMany``2(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Invokes a function on an optional value that itself yields an option
</summary>
</member>
<member name="M:FSharpx.FSharpOption.Select``2(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,``1})">
<summary>
 Transforms an option value by using a specified mapping function
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.OrElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpOption.Aggregate``2(Microsoft.FSharp.Core.FSharpOption{``0},``1,System.Func{``1,``0,``1})">
 <summary>
 Evaluates the equivalent of <see cref="System.Linq.Enumerable.Aggregate"/> for an option
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Funcs.Untuple``4(System.Action{System.Tuple{``0,``1,``2,``3}})">
<summary>
 Converts an action taking a 4-tuple into an action with 4 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``3(System.Action{System.Tuple{``0,``1,``2}})">
<summary>
 /// Converts an action taking a 3-tuple into an action with 3 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``2(System.Action{System.Tuple{``0,``1}})">
<summary>
 Converts an action taking a 2-tuple into an action with 2 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``4(System.Action{``0,``1,``2,``3})">
<summary>
 Converts an action with 4 arguments into an action taking a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``3(System.Action{``0,``1,``2})">
<summary>
 Converts an action with 3 arguments into an action taking a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``2(System.Action{``0,``1})">
<summary>
 Converts an action with 2 arguments into an action taking a 2-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``3(System.Action{``0,``1,``2})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``2(System.Action{``0,``1})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``1(System.Action{``0})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc(System.Action)">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.Curry``4(System.Func{``0,``1,``2,``3})">
<summary>
 Converts an uncurried function to a curried function
</summary>
</member>
<member name="M:FSharpx.Funcs.Curry``3(System.Func{``0,``1,``2})">
<summary>
 Converts an uncurried function to a curried function
</summary>
</member>
<member name="M:FSharpx.Funcs.Compose``3(System.Func{``0,``1},System.Func{``2,``0})">
<summary>
 Composes two functions.
 Mathematically: f . g
</summary>
</member>
<member name="M:FSharpx.Funcs.AndThen``3(System.Func{``0,``1},System.Func{``1,``2})">
<summary>
 Composes two functions (forward composition).
 Mathematically: g . f
</summary>
</member>
<member name="T:FSharpx.Funcs">
<summary>
 Extensions around Actions and Funcs
</summary>
</member>
<member name="M:FSharpx.ISemigroup`1.Combine(`0,`0)">
 <summary>
 Associative operation
 </summary>
</member>
<member name="T:FSharpx.ISemigroup`1">
<summary>
 Semigroup (set with associative binary operation)
</summary>
</member>
<member name="M:FSharpx.L.F``3(System.Func{``0,``1,``2})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``2(System.Func{``0,``1})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``1(System.Func{``0})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="T:FSharpx.L">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid`1.Zero">
 <summary>
 Identity
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid`1.Concat(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Fold a list using this monoid
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid`1.Combine(`0,`0)">
<summary>
 Associative operation
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid`1">
<summary>
 Monoid (associative binary operation with identity)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterDot``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequentially compose two async actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiply``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_MultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Async.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Async.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Transforms an async value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.pipe``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Flipped map
</summary>
</member>
<member name="M:FSharpx.Async.ap``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterEquals``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Async.returnM``1(``0)">
<summary>
 Inject a value into the async type
</summary>
</member>
<member name="M:FSharpx.Async.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequentially compose two actions, passing any value produced by the second as an argument to the first.
</summary>
</member>
<member name="T:FSharpx.Async">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.ofOption``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 If Some value, returns Choice1Of2 value. Otherwise, returns the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Choice.toOption``2">
<summary>
 If Choice is 1Of2, returns Some value. Otherwise, returns None.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.mapSecond``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Transforms a Choice&apos;s second value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.choice``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Choice.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``2,``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Choice.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Choice.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Transforms a Choice&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="M:FSharpx.Choice.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Wraps a function, encapsulates any exception thrown within to a Choice
</summary>
</member>
<member name="M:FSharpx.Choice.get``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="M:FSharpx.Choice.returnM``2(``0)">
<summary>
 Inject a value into the Choice type
</summary>
</member>
<member name="T:FSharpx.Choice">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.ByteString">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Map">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Set">

</member>
<member name="M:FSharpx.Collections.List.monoid``1">
<summary>
 List monoid
</summary>
</member>
<member name="T:FSharpx.Collections.List">

</member>
<member name="">

</member>
<member name="T:FSharpx.Collections.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ContinuationModule.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``3,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequentially compose two continuation actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3},``3}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3},``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Transforms a Cont value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.ap``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.returnM``2(``0)">
<summary>
 Inject a value into the Cont type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.ContinuationModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Extras.AssemblyInfo">

</member>
<member name="T:FSharpx.Functional.Enumeratee`3">
<summary>
 An enumeratee is an enumerator that produces an iteratee using another iteratee as input.
 Enumeratees can be used for tasks such as encoding or encrypting data.
</summary>
</member>
<member name="T:FSharpx.Functional.Enumerator`2">
<summary>
 An enumerator generates a stream of data and feeds an iteratee, returning a new iteratee.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.Iteratee`2">
<summary>
 The iteratee is a stream consumer that will consume a stream of data until either 
 it receives an EOF or meets its own requirements for consuming data. The iteratee
 will return Continue whenever it is ready to receive the next chunk. An iteratee
 is fed data by an Enumerator, which generates a Stream. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.Stream`1">
<summary>
 A stream of chunks of data generated by an Enumerator.
 The stream can be composed of chunks of &apos;T, empty blocks indicating a wait, or an EOF marker.
 Be aware that when using #seq&lt;_&gt; types, you will need to check for both Seq.empty ([]) and Empty.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.Enumerator.scanUntil``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state until the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Functional.Enumerator.scanWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state while the provided predicate is true.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.Enumerator.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.Enumerator">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.IterateeModule.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpx.Functional.Iteratee{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpx.Functional.Iteratee{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpx.Functional.Iteratee{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_GreaterGreaterDot``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,``2})">
<summary>
 Sequentially compose two iteratee actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_LessMultiply``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_MultiplyGreater``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.IterateeModule.ap``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_LessMultiplyGreater``3(FSharpx.Functional.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpx.Functional.Iteratee{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.IterateeModule.BinaryModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.IterateeModule.ListModule">

</member>
<member name="T:FSharpx.Functional.IterateeModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.LensModule.listToArray``2(FSharpx.Functional.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Converts a lens that views a list into a lens that views an array
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.xmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0},FSharpx.Functional.Lens{``2,``0})">
<summary>
 Applies an isomorphism to the value viewed through a lens
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.seqMap``2(FSharpx.Functional.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a sequence
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.arrayMap``2(FSharpx.Functional.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in an array
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.listMap``2(FSharpx.Functional.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a list
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forList``1(System.Int32)">
<summary>
 Lens for a particular position in a list
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forArray``1(System.Int32)">
<summary>
 Lens for a particular position in an array
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forMap``2(``0)">
<summary>
 Lens for a particular key in a map
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forSet``1(``0)">
<summary>
 Lens for a particular value in a set
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.LensModule.id``1">
<summary>
 Identity lens
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.snd``2">
<summary>
 Gets/sets the snd element in a pair
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.fst``2">
<summary>
 Gets/sets the fst element in a pair
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.modifyAndGetState``2(FSharpx.Functional.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the modified value.
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.getAndModifyState``2(FSharpx.Functional.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the original value.
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.updateState``2(FSharpx.Functional.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},``0)">
<summary>
 Update through a lens within a state monad
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.setState``2(FSharpx.Functional.Lens{``0,``1},``1,``0)">
<summary>
 Applies a lens in the &apos;set&apos; direction within a state monad
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.getState``2(FSharpx.Functional.Lens{``0,``1},``0)">
<summary>
 Applies a lens in the &apos;get&apos; direction within a state monad      
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.cond``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``0,``1})">
 <summary>
 <paramref name="pred"/> is applied to source. 
 If true, <paramref name="lensTrue"/> is selected.
 If false, <paramref name="lensFalse"/> is selected.
 </summary>
</member>
<member name="M:FSharpx.Functional.LensModule.pair``4(FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``2,``3})">
<summary>
 Pair two lenses
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.choice``3(FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``2,``1})">
<summary>
 Composes two lenses through a sum in the source
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.compose``3(FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``2,``0})">
<summary>
 Sequentially composes two lenses
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.LensModule.StateOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Functional.LensModule.Operators">

</member>
<member name="T:FSharpx.Functional.LensModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Functional.Prelude.op_Concatenate``2">
<summary>
 Sequencing operator like Haskell&apos;s ($). Has better precedence than (&lt;|) due to the
 first character used in the symbol.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.fix3``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}}},``0,``1,``2)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.fix2``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0,``1)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.fix``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Creates a 6-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Creates a 5-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple4``4(``0,``1,``2,``3)">
<summary>
 Creates a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple3``3(``0,``1,``2)">
<summary>
 Creates a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple2``2(``0,``1)">
<summary>
 Creates a pair
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.konst2``3(``0,``1,``2)">
<summary>
 Given a value, creates a function with two ignored arguments which returns the value.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.konst``2(``0,``1)">
<summary>
 Given a value, creates a function with one ignored argument which returns the value.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.swap``2(``0,``1)">
<summary>
 Swap the elements of a pair.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.curry3``4(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2},``3},``0,``1,``2)">
<summary>
 Transforms an uncurried function to a triple-curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Transforms an uncurried function to a curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Transforms an uncurried function to a curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.flip4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}}},``1,``2,``3,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.flip3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``1,``2,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="T:FSharpx.Functional.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Http.Conneg.bestCharset(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Intersects accepted and served charsets.
 Returns the preferred viable charset, or <c>None</c>.
 </summary>
 <param name="x"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateCharset(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Intersects accepted and served charsets. 
 Returns a list of viable charsets, sorted by client preference in descending order
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="">

</member>
<member name="M:FSharpx.Http.Conneg.matchCharset(System.String,System.String)">
 <summary>
 Matches two charset tags
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.bestLanguage(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served media.
 Returns the preferred viable language, or <c>None</c>.
 </summary>
 <param name="x"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateLanguage(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served languages. 
 Returns a list of viable languages, sorted by client preference in descending order
 </summary>
 <param name="x"></param>
</member>
<member name="M:FSharpx.Http.Conneg.matchLanguage(System.String,System.String)">
 <summary>
 Matches two language tags
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.|AcceptsMedia|_|(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Matches if the media parameter can be handled by the accept list
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.bestMediaType(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served media.
 Returns the preferred viable media, or <c>None</c>.
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.bestOf``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Collections.FSharpList{``2}}},``0,``1)">
 <summary>
 Gets the first item from a list of negotiated items
 </summary>
 <param name="negotiate"></param>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateMediaType(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served media. 
 Returns a list of viable media, sorted by client preference in descending order
 </summary>
 <param name="serves">Served media</param>
 <param name="accepts">Accept header</param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{``1}}},System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Filters and maps a list of served items and a Accept-* header of acceptable items using a matcher function
 </summary>
 <param name="matcher"></param>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateList``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``2,``3}}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>
 Filters and maps two sequences of items using a matcher function.
 </summary>
 <param name="matcher"></param>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.matchMediaType(System.String,System.String)">
 <summary>
 Finds a match between two media types, handling wildcards.
 Returns <c>None</c> if no match, otherwise <c>Some media</c>
 Example: <c>matchMediaType "text/*" "text/plain"</c> -> <c>"text/plain"</c>
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.filterMediaTypes(System.String,System.String)">
 <summary>
 Filters an Accept header by type.
 E.g. <c>filterMediaTypes "image" "image/png,text/html"</c> -> <c>["image/png"]</c>
 </summary>
 <param name="mediaType"></param>
 <param name="accepts"></param>
</member>
<member name="P:FSharpx.Http.Conneg.parseMediaTypes">
 <summary>
 Parses an Accept header into a list of media,(media type, media subtype),q
 E.g. "text/html",("text","html"),0.8
 </summary>
</member>
<member name="M:FSharpx.Http.Conneg.splitMediaTypeSubtype(System.String)">
 <summary>
 Splits media type and subtype, e.g. "text/html" -> "text","html"
 </summary>
 <param name="m"></param>
</member>
<member name="P:FSharpx.Http.Conneg.parseFilterSortAccept">
 <summary>
 Parses any Accept-* header. 
 Removes all items with q=0 (i.e. not acceptable by client).
 Sorts by q descending (client preference)
 </summary>
</member>
<member name="P:FSharpx.Http.Conneg.filterSortAccept">
 <summary>
 Takes a list of items with associated numeric quality (preference), and:
 removes all items with q=0 (i.e. not acceptable by client);
 sorts by q descending (client preference)
 </summary>
</member>
<member name="P:FSharpx.Http.Conneg.parseAccept">
 <summary>
 Parses any Accept-* header, returns a seq of items with associated q (quality/preference)
 </summary>
</member>
<member name="M:FSharpx.Http.Conneg.parseQ(System.String[])">
 <summary>
 Parses a single Accept-* header item. 
 Returns item with associated q
 </summary>
 <param name="s">Header item split by ';'</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Http.Conneg">

</member>
<member name="M:FSharpx.IO.IOPrimitives.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="P:FSharpx.IO.IOPrimitives.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.convertTextToWindowsLineBreaks(System.String)">
<summary>
 Converts the given text from linux or mac linebreaks to windows line breaks
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.replaceFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.writeStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes a single string to a file
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.writeToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.readFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.readFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:FSharpx.IO.IOPrimitives.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.getFullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IO.IOPrimitives">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.JSON.parse(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 Parses a JSON source text and returns an JSON AST
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.JSON.DocumentExtensions">

</member>
<member name="T:FSharpx.JSON">

</member>
<member name="">

</member>
<member name="T:FSharpx.LazyModule">

</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.ToLinqExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Convert the quotation expression to LINQ expression trees

 This operation will only succeed for a subset of quotation expressions.

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.EvaluateUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.Evaluate``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Evaluate the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.CompileUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.Compile``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Linq.QuotationHelpers.toLinqExpression``2(Microsoft.FSharp.Quotations.FSharpExpr{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Converts a Lambda quotation into a Linq Lamba Expression with 1 parameter
</summary>
</member>
<member name="T:FSharpx.Linq.QuotationHelpers">

</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.LinqExpressionHelper``1(``0)">
<summary>
 This function should not be called directly. 
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr`1.Eval``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Evaluate the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr`1.Compile``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.EvalUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.CompileUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.ToLinqExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Convert the quotation expression to LINQ expression trees

 This operation will only succeed for a subset of quotation expressions.

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Linq.QuotationEvaluation.HelperTypes">
<summary>
 A set of types used for implementing quotation conversions.
 These are public only because targets of Linq Lambda expressions require them to be so
</summary>
</member>
<member name="T:FSharpx.Linq.QuotationEvaluation">
<summary>
 This module provides Compile and Eval extension members
 for F# quotation values, implemented by translating to LINQ
 expression trees and using the LINQ dynamic compiler.
</summary>
</member>
<member name="M:FSharpx.Linq.ExtraHashCompare.GenericNotEqualIntrinsic``1(``0,``0)">
<summary>
 An intrinsic for compiling &lt;c&gt;&amp;lt;@ x &lt;&gt; y @&amp;gt;&lt;/c&gt; to expression trees
</summary>
</member>
<member name="T:FSharpx.Linq.ExtraHashCompare">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharpx.Monoid.productInt">
<summary>
 Monoid (int,1,*)
</summary>
</member>
<member name="P:FSharpx.Monoid.sumInt">
<summary>
 Monoid (int,0,+)
</summary>
</member>
<member name="M:FSharpx.Monoid.product``1">
<summary>
 Monoid (a,1,*)
</summary>
</member>
<member name="M:FSharpx.Monoid.sum``1">
<summary>
 Monoid (a,0,+)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid.dual``1(FSharpx.Monoid{``0})">
<summary>
 The dual of a monoid, obtained by swapping the arguments of &apos;Combine&apos;.
</summary>
</member>
<member name="T:FSharpx.Monoid">

</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListenerResponse.AsyncReply(System.Net.HttpListenerResponse,System.String,System.Byte[])">
<summary>
 Sends the specified data as a reply with the specified content type
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListenerResponse.AsyncReply(System.Net.HttpListenerResponse,System.String)">
<summary>
 Sends the specified string as a reply in UTF 8 encoding
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListenerRequest.get_AsyncInputString(System.Net.HttpListenerRequest)">
<summary>
 Asynchronously reads the &apos;InputStream&apos; of the request and converts it to a string
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListener.Start.Static(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Net.HttpListenerRequest,System.Net.HttpListenerResponse},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Starts HttpListener on the specified URL. The &apos;handler&apos; function is
 called (in a new thread pool thread) each time an HTTP request is received.
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListener.AsyncGetContext(System.Net.HttpListener)">
<summary>
 Asynchronously waits for an incoming request and returns it.
</summary>
</member>
<member name="T:FSharpx.Net.HttpExtensions">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Nullable.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Nullable.toList``1(System.Nullable{``0})">
<summary>
 Convert the nullable to a list of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.toArray``1(System.Nullable{``0})">
<summary>
 Convert the nullable to an array of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Nullable{``0})">
<summary>
 Transforms a Nullable value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Nullable.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Nullable{``0})">
<summary>
 Executes a function for a nullable value.
</summary>
</member>
<member name="M:FSharpx.Nullable.forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.forall for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.exists for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Nullable{``0},``1)">
<summary>
 Performs the equivalent of the List.foldBack operation on a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Nullable{``1})">
<summary>
 Evaluates the equivalent of List.fold for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.count``1(System.Nullable{``0})">
<summary>
 Returns 1 if Nullable has value, otherwise 0
</summary>
</member>
<member name="M:FSharpx.Nullable.isNull``1(System.Nullable{``0})">
<summary>
 True if Nullable does not have value
</summary>
</member>
<member name="M:FSharpx.Nullable.hasValue``1(System.Nullable{``0})">
<summary>
 True if Nullable has value
</summary>
</member>
<member name="M:FSharpx.Nullable.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``1}},System.Nullable{``0})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Nullable.toOption``1">
<summary>
 Converts nullable to option
</summary>
</member>
<member name="M:FSharpx.Nullable.ofOption``1">
<summary>
 Converts option to nullable
</summary>
</member>
<member name="M:FSharpx.Nullable.get``1(System.Nullable{``0})">
<summary>
 Gets the value associated with the Nullable.
 If no value, throws.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrElse``1(System.Nullable{``0},System.Lazy{``0})">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrDefault``1(System.Nullable{``0},``0)">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Nullable">

</member>
<member name="M:FSharpx.Operators.applyM``7(``0,``5,``1,``6)">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Operators.returnM``3(``0,``1)">
<summary>
 Inject a value into the monadic type
</summary>
</member>
<member name="T:FSharpx.Operators">
<summary>
 Generic monadic operators    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Option.MaybeBuilder">
<summary>
 The maybe monad.
 This monad is my own and uses an &apos;T option. Others generally make their own Maybe&lt;&apos;T&gt; type from Option&lt;&apos;T&gt;.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
</summary>
</member>
<member name="M:FSharpx.Option.concat``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Concatenates an option of option.
</summary>
</member>
<member name="M:FSharpx.Option.fromTryPattern``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}},``0)">
<summary>
 transforms a function in the Try...(input, out output) style
 into a function of type: input -&gt; output Option
 Example: fromTryPattern(System.Double.TryParse)
 See Examples.Option
</summary>
</member>
<member name="M:FSharpx.Option.option``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Haskell-style maybe operator
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Option.Cast``1(System.Object)">
<summary>
 Attempts to cast an object. Returns None if unsuccessful.
</summary>
</member>
<member name="M:FSharpx.Option.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.orElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrDefault``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the default value for the type.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseF``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value from a function.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseLazy``1(System.Lazy{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElse``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.ofChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Maps Choice 1Of2 to Some value, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.ofBoolAndValue``1(System.Boolean,``0)">
<summary>
 If true,value then returns Some value. Otherwise returns None.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.tryParseWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}})">
<summary>
 Converts a function returning bool,value to a function returning value option.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.ofBool(System.Boolean)">
<summary>
 True -&gt; Some(), False -&gt; None
</summary>
</member>
<member name="M:FSharpx.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Maps an Option to Nullable
</summary>
</member>
<member name="M:FSharpx.Option.ofNullable``1(System.Nullable{``0})">
<summary>
 Maps a Nullable to Option
</summary>
</member>
<member name="M:FSharpx.Option.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequentially compose two maybe actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Option.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Option.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Option.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Option.ap``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Option.returnM``1(``0)">
<summary>
 Inject a value into the option type
</summary>
</member>
<member name="M:FSharpx.Option.monoid``1(FSharpx.ISemigroup{``0})">
<summary>
 Option wrapper monoid
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader.ReaderBuilder">
<summary>
 The reader monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/07/much-ado-about-monads-reader-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Reader.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequentially compose two reader actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Reader.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Reader.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,``0},Microsoft.FSharp.Core.FSharpFunc{``3,``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Reader.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Transforms a Reader value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Reader.ap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Reader.returnM``2(``0)">
<summary>
 Inject a value into the Reader type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Semigroup">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State.StateBuilder">
<summary>
 The state monad.
 The algorithm is adjusted from my original work off of Brian Beckman&apos;s http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
 The approach was adjusted from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.State.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.State.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.State.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,``3}},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``1,``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.State.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.State.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Transforms a State value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.State.ap``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2}},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.State.returnM``2(``0)">
<summary>
 Inject a value into the State type
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ListQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.ArrayQueue">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core.TLog">
<summary>
 A transactional memory log
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core.TVar`1">
<summary>
 A transactional variable 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core.TVar">
<summary>
 A base type for transactional variables
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Stm.Core">

</member>
<member name="T:FSharpx.Stm">
 <summary>The Software Transactional Memory monad.</summary>
 <see href="http://web.archive.org/web/20110926161739/http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx" />
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Task.Result`1.Successful">
<summary>
 Task completed successfully
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Error">
<summary>
 Unhandled exception in task
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Canceled">
<summary>
 Task was canceled
</summary>
</member>
<member name="T:FSharpx.Task.Result`1">
<summary>
 Task result
</summary>
</member>
<member name="M:FSharpx.Task.op_LessMultiply``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Task.op_MultiplyGreater``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Task.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Task.op_LessMultiplyGreater``2(System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Threading.Tasks.Task{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Task.ap``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Task.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Task.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Threading.Tasks.Task{``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterGreaterDot``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Task.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},System.Threading.Tasks.Task{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterGreaterEquals``2(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Task.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Transforms a Task&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Task.mapWithOptions``2(System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Transforms a Task&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Task">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Text.Pluralizer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Text.RegexModule.tryMatchWithOptions(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
flags:RegexOptions -&gt; pattern:string -&gt; input:string -&gt; Regex.ActiveMatch option
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Text.RegexModule.Interpreted">

</member>
<member name="">

</member>
<member name="T:FSharpx.Text.RegexModule.Compiled">

</member>
<member name="T:FSharpx.Text.RegexModule">

</member>
<member name="M:FSharpx.Text.Strings.inferType(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks whether all values of the sequence can be inferred to a special type
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isFloat(System.String)">
<summary>
 Checks whether the string is a float
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isInt64(System.String)">
<summary>
 Checks whether the string is an int64
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isInt(System.String)">
<summary>
 Checks whether the string is an int32
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isBool(System.String)">
<summary>
 Checks whether the string is a boolean value
</summary>
</member>
<member name="M:FSharpx.Text.Strings.niceName(System.String)">
<summary>
 Turns a string into a nice PascalCase identifier
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Text.Strings.singularize(System.String)">
<summary>
 Returns the singularized version of a noun
</summary>
</member>
<member name="M:FSharpx.Text.Strings.pluralize(System.String)">
<summary>
 Returns the pluralized version of a noun
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="M:FSharpx.Text.Strings.joinWords(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Folds the string list by seperating entries with a single space
</summary>
</member>
<member name="M:FSharpx.Text.Strings.toWords(System.String)">
<summary>
 Splits a string based on whitespace (spaces, tabs, and newlines)
</summary>
</member>
<member name="M:FSharpx.Text.Strings.joinLines(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Creates newline seperated string from the string list
</summary>
</member>
<member name="M:FSharpx.Text.Strings.toLines(System.String)">
<summary>
 Splits a string based on newlines 
</summary>
</member>
<member name="M:FSharpx.Text.Strings.splitBy(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 Returns a sequence of strings split by the predicate    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Text.Strings.separatedBy(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a single string separated with the delimiters
</summary>
</member>
<member name="M:FSharpx.Text.Strings.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:FSharpx.Text.Strings.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether the specified substring occurs within this string
</summary>
</member>
<member name="M:FSharpx.Text.Strings.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given &quot;replacement&quot; for every occurence of the pattern in the given text 
</summary>
</member>
<member name="M:FSharpx.Text.Strings.startsWith(System.String,System.String)">
<summary>
 Checks whether the given text starts with the given prefix
</summary>
</member>
<member name="T:FSharpx.Text.Strings">

</member>
<member name="M:FSharpx.TimeMeasurement.compareTwoRuntimes``2(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Stops the average runtime for the given functions
 Afterwards it reports it with the given descriptions
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAndReportAvarageTime``1(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
 Afterwards it reports it with the given description
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAverageTime``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopTime``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the runtime for a given function
</summary>
</member>
<member name="T:FSharpx.TimeMeasurement">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Undo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.CustomValidation`1.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apr``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apl``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.ap``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``3}},Microsoft.FSharp.Core.FSharpChoice{``1,FSharpx.Collections.NonEmptyList{``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.NonEmptyList{``2}},Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.apm``3(FSharpx.ISemigroup{``0})">
<summary>
 Sequential application, parameterized by semigroup
</summary>
</member>
<member name="M:FSharpx.Validation.apa``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpChoice{``1,``0},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``1,``2},``0})">
<summary>
 Sequential application, parameterized by append
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Validation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Writer.WriterBuilder`1">
<summary>
 The writer monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``2,Microsoft.FSharp.Collections.FSharpList{System.String}}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Writer.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Writer.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Writer.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Transforms a Writer value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Writer.ap``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.returnM``2(FSharpx.Monoid{``0},``1,Microsoft.FSharp.Core.Unit)">
<summary>
 Inject a value into the Writer type
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Writer">

</member>
<member name="M:FSharpx.ZipList.op_LessMultiply``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.op_MultiplyGreater``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ZipList.ap``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiplyGreater``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.ZipList">

</member>
</members>
</doc>
